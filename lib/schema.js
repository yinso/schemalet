// Generated by CoffeeScript 1.10.0
(function() {
  var AllOfSchema, AndConstraint, AppError, ArraySchema, BooleanSchema, Constraint, EnumConstraint, FormatConstraint, IntegerSchema, InterfaceSchema, MapSchema, MaxItemsConstraint, MaxLengthConstraint, MaximumConstraint, MinItemsConstraint, MinLengthConstraint, MinimumConstraint, MultipleOfConstraint, NullSchema, NumberSchema, ObjectSchema, OneOfSchema, PatternConstraint, ProcedureSchema, Promise, Schema, SchemaEnv, SchemaPath, StringSchema, TupleSchema, UniqueItemsConstraint, _extend, _isFunction, formatConstraintMap,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  AppError = require('errorlet');

  Promise = require('bluebird');

  _extend = function() {
    var k, key, len, sources, src, target, val;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    for (k = 0, len = sources.length; k < len; k++) {
      src = sources[k];
      for (key in src) {
        val = src[key];
        target[key] = val;
      }
    }
    return target;
  };

  _isFunction = function(v) {
    return typeof v === 'function' || (v instanceof Function);
  };

  SchemaEnv = (function() {
    function SchemaEnv() {}

    return SchemaEnv;

  })();

  SchemaPath = (function() {
    function SchemaPath(path, prev) {
      if (path == null) {
        path = '';
      }
      if (prev == null) {
        prev = null;
      }
      if (!(this instanceof SchemaPath)) {
        return new SchemaPath(path, prev);
      }
      this.path = path;
      this.prev = prev;
    }

    SchemaPath.prototype.push = function(path) {
      return new SchemaPath(path, this);
    };

    SchemaPath.prototype.toString = function() {
      var current, res;
      res = [];
      current = this;
      while (current) {
        res.unshift(current.path);
        current = current.prev;
      }
      return res.join('/');
    };

    SchemaPath.prototype.toJSON = function() {
      return this.toString();
    };

    return SchemaPath;

  })();

  Constraint = (function() {
    function Constraint() {}

    Constraint.prototype.check = function(v) {
      return false;
    };

    Constraint.prototype.validate = function(v) {
      return new AppError({
        error: 'constraintError',
        type: this.type,
        value: v
      });
    };

    Constraint.prototype.equal = function(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof this.constructor)) {
        return false;
      }
      return this._equal(other);
    };

    return Constraint;

  })();

  EnumConstraint = (function(superClass) {
    extend(EnumConstraint, superClass);

    function EnumConstraint(type1) {
      var item;
      this.type = type1;
      this["enum"] = (function() {
        var k, len, ref, results;
        ref = this.type.schema["enum"];
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          item = ref[k];
          results.push(this.type.convert(item));
        }
        return results;
      }).call(this);
    }

    EnumConstraint.prototype.check = function(v) {
      var item, k, len, ref;
      ref = this["enum"];
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (this.type.valueEqual(item, v)) {
          return true;
        }
      }
      return false;
    };

    EnumConstraint.prototype.equal = function(other) {
      var i, item, k, len, ref;
      if (this["enum"].length !== other["enum"].length) {
        return false;
      }
      ref = this["enum"];
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        item = ref[i];
        if (!this.type.valueEqual(item, other["enum"][i])) {
          return false;
        }
      }
      return true;
    };

    EnumConstraint.prototype.toJSON = function() {
      var item;
      return {
        "enum": (function() {
          var k, len, ref, results;
          ref = this["enum"];
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            item = ref[k];
            results.push(item);
          }
          return results;
        }).call(this)
      };
    };

    return EnumConstraint;

  })(Constraint);

  AndConstraint = (function(superClass) {
    extend(AndConstraint, superClass);

    function AndConstraint(type1, constraints) {
      this.type = type1;
      this.constraints = constraints;
    }

    AndConstraint.prototype.check = function(v) {
      var cons, k, len, ref;
      ref = this.constraints;
      for (k = 0, len = ref.length; k < len; k++) {
        cons = ref[k];
        if (!cons.check(v)) {
          return false;
        }
      }
      return true;
    };

    AndConstraint.prototype._equal = function(other) {
      var cons, i, k, len, ref;
      if (this.constraints.length !== other.constraints.length) {
        return false;
      }
      ref = this.constraints;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        cons = ref[i];
        if (!cons.equal(other.constraints[i])) {
          return false;
        }
      }
      return true;
    };

    AndConstraint.prototype.toJSON = function() {
      var cons, inner, k, len, ref, res;
      res = {};
      ref = this.constraints;
      for (k = 0, len = ref.length; k < len; k++) {
        cons = ref[k];
        inner = cons.toJSON();
        _extend(res, inner);
      }
      return res;
    };

    return AndConstraint;

  })(Constraint);

  MultipleOfConstraint = (function(superClass) {
    extend(MultipleOfConstraint, superClass);

    function MultipleOfConstraint(type1) {
      this.type = type1;
      this.multiple = this.type.convert(this.type.schema.multipleOf);
    }

    MultipleOfConstraint.prototype.check = function(v) {
      return (v % this.multiple) === 0;
    };

    MultipleOfConstraint.prototype._equal = function(other) {
      if (!this.type.valueEqual(this.multiple, other.multiple)) {
        return false;
      }
      return true;
    };

    MultipleOfConstraint.prototype.toJSON = function() {
      return {
        multipleOf: this.multiple
      };
    };

    return MultipleOfConstraint;

  })(Constraint);

  MinimumConstraint = (function(superClass) {
    extend(MinimumConstraint, superClass);

    function MinimumConstraint(type1) {
      this.type = type1;
      this.minimum = this.type.convert(this.type.schema.minimum);
      this.exclusive = this.type.schema.exclusiveMinimum;
    }

    MinimumConstraint.prototype.check = function(v) {
      if (this.exclusive) {
        return v > this.minimum;
      } else {
        return v >= this.minimum;
      }
    };

    MinimumConstraint.prototype.equal = function(other) {
      if (other instanceof MinimumConstraint) {
        if (!this.type.equal(other.type)) {
          return false;
        }
        if (!this.type.valueEqual(this.minimum, other.minimum)) {
          return false;
        }
        return this.exclusive === other.exclusive;
      } else {
        return false;
      }
    };

    MinimumConstraint.prototype.toJSON = function() {
      var res;
      res = {
        minimum: this.minimum
      };
      if (this.exclusive) {
        res.exclusiveMinimum = true;
      }
      return res;
    };

    return MinimumConstraint;

  })(Constraint);

  MaximumConstraint = (function(superClass) {
    extend(MaximumConstraint, superClass);

    function MaximumConstraint(type1) {
      this.type = type1;
      this.maximum = this.type.convert(this.type.schema.maximum);
      this.exclusive = this.type.schema.exclusiveMaximum;
    }

    MaximumConstraint.prototype.check = function(v) {
      if (this.exclusive) {
        return v < this.maximum;
      } else {
        return v <= this.maximum;
      }
    };

    MaximumConstraint.prototype.equal = function(other) {
      if (other instanceof MaximumConstraint) {
        if (!this.type.equal(other.type)) {
          return false;
        }
        if (!this.type.valueEqual(this.maximum, other.maximum)) {
          return false;
        }
        return this.exclusive === other.exclusive;
      } else {
        return false;
      }
    };

    MaximumConstraint.prototype.toJSON = function() {
      var res;
      res = {
        maximum: this.maximum
      };
      if (this.exclusive) {
        res.exclusiveMaximum = true;
      }
      return res;
    };

    return MaximumConstraint;

  })(Constraint);

  MinLengthConstraint = (function(superClass) {
    extend(MinLengthConstraint, superClass);

    function MinLengthConstraint(type1) {
      this.type = type1;
      this.minimum = this.type.convert(this.type.schema.minLength);
    }

    MinLengthConstraint.prototype.check = function(v) {
      return v.length >= this.minimum;
    };

    MinLengthConstraint.prototype.equal = function(other) {
      if (other instanceof MinLengthConstraint) {
        if (!this.type.equal(other.type)) {
          return false;
        }
        return this.type.valueEqual(this.minimum, other.minimum);
      } else {
        return false;
      }
    };

    MinLengthConstraint.prototype.toJSON = function() {
      return {
        minimum: this.minimum
      };
    };

    return MinLengthConstraint;

  })(Constraint);

  MaxLengthConstraint = (function(superClass) {
    extend(MaxLengthConstraint, superClass);

    function MaxLengthConstraint(type1) {
      this.type = type1;
      this.maximum = this.type.convert(this.type.schema.maxLength);
    }

    MaxLengthConstraint.prototype.check = function(v) {
      return v.length <= this.maximum;
    };

    MaxLengthConstraint.prototype.equal = function(other) {
      if (other instanceof MaxLengthConstraint) {
        if (!this.type.equal(other.type)) {
          return false;
        }
        return this.type.valueEqual(this.maximum, other.maximum);
      } else {
        return false;
      }
    };

    MaxLengthConstraint.prototype.toJSON = function() {
      return {
        maximum: this.maximum
      };
    };

    return MaxLengthConstraint;

  })(Constraint);

  PatternConstraint = (function(superClass) {
    extend(PatternConstraint, superClass);

    function PatternConstraint(type1) {
      this.type = type1;
      this.pattern = this.type.schema.pattern;
    }

    PatternConstraint.prototype.check = function(v) {
      return v.match(this.pattern);
    };

    PatternConstraint.prototype.equal = function(other) {
      if (other instanceof PatternConstraint) {
        if (!this.type.equal(other.type)) {
          return false;
        }
        return this.pattern === other.pattern;
      } else {
        return false;
      }
    };

    PatternConstraint.prototype.toJSON = function() {
      return {
        pattern: this.pattern.toJSON()
      };
    };

    return PatternConstraint;

  })(Constraint);

  formatConstraintMap = {
    'date-time': function(v) {
      return v.match(/^\d{4}-?\d{2}-?\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/);
    },
    uuid: function(v) {
      return v.match(/^[a-zA-Z0-9]{8}-?[a-zA-Z0-9]{4}-?[a-zA-Z0-9]{4}-?[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/);
    }
  };

  FormatConstraint = (function(superClass) {
    extend(FormatConstraint, superClass);

    function FormatConstraint(type1) {
      this.type = type1;
      this.format = this.type.schema.format;
      if (!formatConstraintMap.hasOwnProperty(this.format)) {
        throw new AppError({
          error: 'UnknownFormat',
          format: this.format,
          method: 'FormatConstraint.ctor'
        });
      }
    }

    FormatConstraint.prototype.check = function(v) {
      return formatConstraintMap[this.format](v);
    };

    FormatConstraint.prototype.equal = function(other) {
      return (other instanceof FormatConstraint) && this.format === other.format;
    };

    return FormatConstraint;

  })(Constraint);

  Schema = (function() {
    Schema.SchemaPath = SchemaPath;

    Schema.SchemaEnv = SchemaEnv;

    function Schema(schema1, prev1) {
      this.schema = schema1;
      this.prev = prev1;
      if (this.isOptional()) {
        this.validate(this.getDefaultValue());
      }
      if (this.schema.hasOwnProperty('$base')) {
        if (this.schema.$base instanceof Schema) {
          this.$base = this.verifyBase(this.schema.$base);
        } else if (this.schema.$base.hasOwnProperty('_schema')) {
          this.$base = this.verifyBase(this.schema.$base._schema);
        } else {
          throw new AppError({
            type: 'invalidBase',
            schema: this.schema
          });
        }
      }
      if (this.schema.hasOwnProperty('$class')) {
        if (_isFunction(this.schema.$class)) {
          this.$class = this.schema.$class;
        } else {
          throw new AppError({
            type: 'invalidClass',
            schema: this.schema
          });
        }
      }
      this.initConstraints();
    }

    Schema.prototype.convert = function(v, schemaPath) {
      if (schemaPath == null) {
        schemaPath = new SchemaPath();
      }
      if ((v === null || v === void 0) && this.isOptional()) {
        return this.getDefaultValue();
      } else if (this.isa(v)) {
        if (this.$class) {
          if (v instanceof this.$class) {
            return v;
          } else {
            return new this.$class(v);
          }
        } else {
          return v;
        }
      } else {
        return this.valueConvert(v, schemaPath);
      }
    };

    Schema.prototype.isRequired = function() {
      return !this.isOptional();
    };

    Schema.prototype.isOptional = function() {
      return this.schema.hasOwnProperty('default') || this.schema.hasOwnProperty('defaultProc');
    };

    Schema.prototype.getDefaultValue = function() {
      if (this.schema.hasOwnProperty('defaultProc')) {
        return this.schema.defaultProc.apply(this, arguments);
      } else if (this.schema.hasOwnProperty('default')) {
        return this.schema["default"];
      }
    };

    Schema.prototype.equal = function(other) {
      if (!(other instanceof this.constructor)) {
        return false;
      }
      if (this.$base) {
        if (!other.$base) {
          return false;
        }
        if (!this.$base.equal(other.$base)) {
          return false;
        }
      }
      if (this.constraint) {
        if (!other.constraint) {
          return false;
        }
        if (!this.constraint.equal(other.constraint)) {
          return false;
        }
      }
      return this._equal(other);
    };

    Schema.prototype._equal = function(other) {
      return true;
    };

    Schema.prototype.valueEqual = function(a, b) {
      return a === b;
    };

    Schema.prototype.isa = function(v) {
      if (this.hasOwnProperty('$base')) {
        if (!this.$base.isa(v)) {
          return false;
        }
      }
      if (this.hasOwnProperty('$class')) {
        if (v instanceof this.$class) {
          return true;
        }
      }
      if (!this.isType(v)) {
        return false;
      }
      if (!this.checkConstraints(v)) {
        return false;
      }
      return true;
    };

    Schema.prototype.validate = function(v) {
      if (!this.isa(v)) {
        this.invalidType(v);
      }
      return v;
    };

    Schema.constraintMap = {
      "enum": EnumConstraint
    };

    Schema.prototype.initConstraints = function() {
      var cons, ctor, key, ref;
      cons = [];
      ref = this.constructor.constraintMap;
      for (key in ref) {
        ctor = ref[key];
        if (this.schema.hasOwnProperty(key)) {
          cons.push(new ctor(this));
        }
      }
      if (cons.length > 0) {
        return this.constraint = new AndConstraint(this, cons);
      }
    };

    Schema.prototype.checkConstraints = function(v) {
      if (this.constraint instanceof Constraint) {
        return this.constraint.check(v);
      } else {
        return true;
      }
    };

    Schema.prototype.invalidType = function(v, schemaPath) {
      var err;
      err = {
        error: 'invalidType',
        schema: this.schema,
        path: schemaPath,
        value: v
      };
      throw new AppError(err, this.invalidType);
    };

    Schema.prototype.absPath = function() {
      var currentPath, prevPath;
      currentPath = this.schema.hasOwnProperty('id') ? this.schema.id : '.';
      prevPath = this.prev instanceof Schema ? this.prev.absPath() : '$';
      return [prevPath, currentPath].join('/');
    };

    Schema.prototype.getRoot = function() {
      if (this.prev) {
        return this.prev.getRoot();
      } else {
        return this;
      }
    };

    Schema.prototype.getPrev = function() {
      if (this.prev) {
        return this.prev;
      } else {
        throw new AppError({
          error: 'alreadyAtRoot',
          schema: this.schema
        });
      }
    };

    Schema.prototype.normalizePath = function(refPath) {
      var i, k, len, res, seg, segs;
      segs = refPath.split('/');
      res = [];
      for (i = k = 0, len = segs.length; k < len; i = ++k) {
        seg = segs[i];
        if (i > 0 && seg === '') {
          continue;
        } else if (i > 0 && seg === '.') {
          continue;
        } else {
          res.push(seg);
        }
      }
      return res;
    };

    Schema.prototype.resolve = function(refPath) {
      var current, i, k, len, seg, segs;
      segs = this.normalizePath(refPath);
      current = this;
      for (i = k = 0, len = segs.length; k < len; i = ++k) {
        seg = segs[i];
        if (seg === '') {
          if (i === 0) {
            current = current.getRoot();
          }
          continue;
        } else if (seg === '.') {
          continue;
        } else if (seg === '..') {
          current = current.getPrev();
        } else {
          current = current.resolveName(seg);
        }
      }
      return current;
    };

    Schema.prototype.resolveName = function(name) {
      return this.unknownProperty(name);
    };

    Schema.prototype.unknownProperty = function(name, schemaPath) {
      var err;
      err = {
        error: 'unknownProperty',
        schema: this.schema,
        path: schemaPath,
        name: name
      };
      throw new AppError(err, this.unknownProperty);
    };

    Schema.prototype.verifyBase = function(baseSchema) {
      if (baseSchema instanceof this.constructor) {
        return baseSchema;
      } else {
        return this.invalidBaseType();
      }
    };

    Schema.prototype.invalidBaseType = function() {
      var err;
      err = {
        error: 'invalidBaseType',
        type: this.schema.type
      };
      throw new AppError(err, this.invalidBaseType);
    };

    Schema.prototype.finalTypeNonDerivable = function() {
      var err;
      err = {
        error: 'finalTypeNotDerivable',
        type: this.schema.type
      };
      throw new AppError(err, this.finalTypeNonDerivable);
    };

    Schema.prototype.specialize = function(schema) {
      return this;
    };

    Schema.prototype.toJSON = function() {
      var allOf, key, ref, res, val;
      if (this.hasOwnProperty('$base')) {
        allOf = this.$base.toJSON();
        return {
          allOf: (allOf.hasOwnProperty('allOf') ? allOf.allOf : [allOf]).concat([this.toJSONInner()])
        };
      } else {
        res = this.toJSONInner();
        ref = this.schema;
        for (key in ref) {
          val = ref[key];
          if (key.match(/^\$/) && !(val instanceof Object)) {
            res[key] = val;
          } else if (key === 'id' || key === 'name' || key === 'description' || key === 'title') {
            res[key] = val;
          }
        }
        return res;
      }
    };

    Schema.prototype.toJSONInner = function() {
      var res;
      res = {
        type: this.schema.type
      };
      if (this.hasOwnProperty('constraint')) {
        _extend(res, this.constraint.toJSON());
      }
      return _extend(res, this._toJSON());
    };

    Schema.prototype._toJSON = function() {
      return {};
    };

    Schema.makeFunction = function(schema, proc) {
      var schemaObj;
      schemaObj = schema instanceof ProcedureSchema ? schema : (schema.type = 'function', this.makeSchema(schema));
      return schemaObj.makeFunction(proc);
    };

    Schema.makeClass = function(schema, $init, $prototype, $base, $static) {
      var Ctor, Parent, getSchema, key, name, schemaObj, val;
      name = schema.hasOwnProperty('id') ? schema.id : 'SchemaClass';
      schemaObj = schema instanceof Schema ? schema : this.makeSchema(schema);
      $init = $init || schema.$init || function(options) {
        return _extend(this, options);
      };
      $prototype = $prototype || schema.$prototype || {};
      $base = $prototype.$base || schema.$base;
      if (!_isFunction($init)) {
        throw new AppError({
          error: 'RequiredParameter',
          name: '$init',
          message: '$init must be a function',
          method: 'Schema::makeClass'
        });
      }
      getSchema = function() {
        return schemaObj;
      };
      Ctor = function(arg) {
        var res;
        if (!(this instanceof Ctor)) {
          return new Ctor(arg);
        }
        res = schemaObj.valueConvert(arg);
        $init.call(this, arg);
      };
      Ctor._schema = schemaObj;
      if ($base) {
        if (_isFunction($base)) {
          require('util').inherits(Ctor, schema.$base);
        } else if ($base instanceof Schema) {
          Parent = this.makeClass(schema.$base);
          require('util').inherits(Ctor, Parent);
        } else if ($base instanceof Object) {
          Ctor.prototype = schema.base;
        } else {
          throw new AppError({
            error: 'MakeClass.invalidBase',
            method: 'Schema.makeClass',
            schema: schema
          });
        }
      }
      for (key in $prototype) {
        val = $prototype[key];
        Ctor.prototype[key] = val;
      }
      schema.$class = Ctor;
      return Ctor;
    };

    Schema.makeSchema = function(schema, prev) {
      if (prev == null) {
        prev = null;
      }
      if (!(schema instanceof Object)) {
        throw new AppError({
          error: 'not_an_object',
          method: 'SimpleSchema.ctor'
        });
      }
      if (schema instanceof Schema) {
        return schema;
      }
      if (_isFunction(schema)) {
        return this.makeOneSchema({
          type: 'object',
          $init: schema
        });
      }
      if (schema.type instanceof Array) {
        return new OneOfSchema(schema, prev);
      } else {
        return this.makeOneSchema(schema, prev);
      }
    };

    Schema.makeOneSchema = function(schema, prev) {
      if (schema.$ref) {
        return this.resolveSchema(schema, prev);
      }
      switch (schema.type) {
        case 'integer':
          return new IntegerSchema(schema, prev);
        case 'number':
          return new NumberSchema(schema, prev);
        case 'boolean':
          return new BooleanSchema(schema, prev);
        case 'string':
          return new StringSchema(schema, prev);
        case 'null':
          return new NullSchema(schema, prev);
        case 'array':
          if (schema.items instanceof Array) {
            return new TupleSchema(schema, prev);
          } else {
            return new ArraySchema(schema, prev);
          }
          break;
        case 'function':
        case 'procedure':
          return new ProcedureSchema(schema, prev);
        case 'interface':
          return new InterfaceSchema(schema, prev);
        default:
          if (schema.hasOwnProperty('additionalProperties')) {
            return new MapSchema(schema, prev);
          } else {
            return new ObjectSchema(schema, prev);
          }
      }
    };

    Schema.resolveSchema = function(schema, prev) {
      var current;
      current = schema.$ref instanceof Schema ? schema.$ref : prev.resolve(schema.$ref);
      return current.specialize(schema);
    };

    Schema.setFormat = function(fmt, checker) {
      var checkProc;
      checkProc = (function() {
        if (checker instanceof RegExp) {
          return function(v) {
            return v.match(checker);
          };
        } else if (_isFunction(checker)) {
          return checker;
        } else {
          throw new AppError({
            error: 'UnknownType',
            message: 'checker_must_be_function_or_regexp',
            method: 'Schema.setFormat',
            checker: checker
          });
        }
      })();
      return formatConstraintMap[fmt] = checkProc;
    };

    return Schema;

  })();

  NumberSchema = (function(superClass) {
    extend(NumberSchema, superClass);

    function NumberSchema() {
      return NumberSchema.__super__.constructor.apply(this, arguments);
    }

    NumberSchema.prototype.type = 'number';

    NumberSchema.prototype.isType = function(v) {
      return typeof v === 'number';
    };

    NumberSchema.prototype.valueConvert = function(v, schemaPath) {
      var val;
      if (typeof v === 'string') {
        val = parseFloat(v);
        if (val.toString() === v) {
          return val;
        } else {
          return this.invalidType(v, schemaPath);
        }
      } else {
        return this.invalidType(v, schemaPath);
      }
    };

    NumberSchema.constraintMap = {
      "enum": EnumConstraint,
      multipleOf: MultipleOfConstraint,
      minimum: MinimumConstraint,
      maximum: MaximumConstraint
    };

    NumberSchema.prototype.verifyBase = function(baseSchema) {
      if ((baseSchema instanceof NumberSchema) && !(baseSchema instanceof IntegerSchema)) {
        return baseSchema;
      } else {
        return this.invalidBaseType();
      }
    };

    NumberSchema.prototype.specialize = function(schema) {
      var k, key, keys, len;
      keys = ['multipleOf', 'minimum', 'maximum', 'exclusiveMaximum', 'exclusiveMinimum'];
      for (k = 0, len = keys.length; k < len; k++) {
        key = keys[k];
        if (schema.hasOwnProperty(key)) {
          return new this.constructor(schema);
        }
      }
      return this;
    };

    return NumberSchema;

  })(Schema);

  IntegerSchema = (function(superClass) {
    extend(IntegerSchema, superClass);

    function IntegerSchema() {
      return IntegerSchema.__super__.constructor.apply(this, arguments);
    }

    IntegerSchema.prototype.type = 'integer';

    IntegerSchema.prototype.isType = function(v) {
      return IntegerSchema.__super__.isType.call(this, v) && Math.floor(v) === v;
    };

    IntegerSchema.prototype.valueConvert = function(v, schemaPath) {
      var val;
      if (typeof v === 'string') {
        val = parseInt(v);
        if (val.toString() === v) {
          return val;
        } else {
          return this.invalidType(v, schemaPath);
        }
      } else {
        return this.invalidType(v, schemaPath);
      }
    };

    IntegerSchema.prototype.verifyBase = function(baseSchema) {
      return Schema.prototype.verifyBase.call(this, baseSchema);
    };

    return IntegerSchema;

  })(NumberSchema);

  BooleanSchema = (function(superClass) {
    extend(BooleanSchema, superClass);

    function BooleanSchema() {
      return BooleanSchema.__super__.constructor.apply(this, arguments);
    }

    BooleanSchema.prototype.type = 'boolean';

    BooleanSchema.prototype.isType = function(v) {
      return typeof v === 'boolean';
    };

    BooleanSchema.prototype.valueConvert = function(v, schemaPath) {
      if (typeof v === 'string') {
        if (v === 'true') {
          return true;
        } else if (v === 'false') {
          return false;
        } else {
          return this.invalidType(v, schemaPath);
        }
      } else {
        return this.invalidType(v, schemaPath);
      }
    };

    BooleanSchema.prototype.verifyBase = function(baseSchema) {
      return this.finalTypeNonDerivable();
    };

    return BooleanSchema;

  })(Schema);

  StringSchema = (function(superClass) {
    extend(StringSchema, superClass);

    function StringSchema() {
      return StringSchema.__super__.constructor.apply(this, arguments);
    }

    StringSchema.prototype.type = 'string';

    StringSchema.constraintMap = {
      "enum": EnumConstraint,
      minLength: MinLengthConstraint,
      maxLength: MaxLengthConstraint,
      pattern: PatternConstraint,
      format: FormatConstraint
    };

    StringSchema.prototype.isType = function(v) {
      return typeof v === 'string' || v instanceof String;
    };

    StringSchema.prototype.valueConvert = function(v) {
      return v.toString();
    };

    return StringSchema;

  })(Schema);

  NullSchema = (function(superClass) {
    extend(NullSchema, superClass);

    function NullSchema() {
      return NullSchema.__super__.constructor.apply(this, arguments);
    }

    NullSchema.prototype.type = 'null';

    NullSchema.prototype.isType = function(v) {
      return v === null;
    };

    NullSchema.prototype.valueConvert = function(v, schemaPath) {
      if (v === 'null') {
        return null;
      } else {
        return this.invalidType(v, schemaPath);
      }
    };

    NullSchema.prototype.verifyBase = function(baseSchema) {
      return this.finalTypeNonDerivable();
    };

    NullSchema.prototype._toJSON = function() {
      var constraint, schema;
      constraint = this.hasOwnProperty('constraint') ? this.constraint.toJSON() : {};
      schema = {
        type: 'null'
      };
      return _extend(schema, constraint);
    };

    return NullSchema;

  })(Schema);

  MinItemsConstraint = (function(superClass) {
    extend(MinItemsConstraint, superClass);

    function MinItemsConstraint(type1) {
      this.type = type1;
      this.minimum = this.type.schema.minItems;
    }

    MinItemsConstraint.prototype.check = function(v) {
      return v.length >= this.minimum;
    };

    MinItemsConstraint.prototype.toJSON = function() {
      return {
        minItems: this.minimum
      };
    };

    return MinItemsConstraint;

  })(Constraint);

  MaxItemsConstraint = (function(superClass) {
    extend(MaxItemsConstraint, superClass);

    function MaxItemsConstraint(type1) {
      this.type = type1;
      this.maximum = this.type.schema.maxItems;
    }

    MaxItemsConstraint.prototype.check = function(v) {
      return v.length <= this.maximum;
    };

    MaxItemsConstraint.prototype.toJSON = function() {
      return {
        maxItems: this.maximum
      };
    };

    return MaxItemsConstraint;

  })(Constraint);

  UniqueItemsConstraint = (function(superClass) {
    extend(UniqueItemsConstraint, superClass);

    function UniqueItemsConstraint(type1) {
      this.type = type1;
      this.unique = this.type.schema.uniqueItems;
    }

    UniqueItemsConstraint.prototype._equal = function(other) {
      if (!this.type.equal(other.type)) {
        return false;
      }
      return this.unique === other.unique;
    };

    UniqueItemsConstraint.prototype.check = function(v) {
      var i, j, k, l, len, len1, x, y;
      if (this.unique) {
        for (i = k = 0, len = v.length; k < len; i = ++k) {
          x = v[i];
          for (j = l = 0, len1 = v.length; l < len1; j = ++l) {
            y = v[j];
            if (i !== j) {
              if (this.type.valueEqual(x, y)) {
                return false;
              }
            }
          }
        }
        return true;
      } else {
        return true;
      }
    };

    UniqueItemsConstraint.prototype.toJSON = function() {
      return {
        unique: true
      };
    };

    return UniqueItemsConstraint;

  })(Constraint);

  ArraySchema = (function(superClass) {
    extend(ArraySchema, superClass);

    ArraySchema.prototype.type = 'array';

    ArraySchema.constraintMap = {
      "enum": EnumConstraint,
      minItems: MinItemsConstraint,
      maxItems: MaxItemsConstraint,
      uniqueItems: UniqueItemsConstraint
    };

    function ArraySchema(schema, prev) {
      ArraySchema.__super__.constructor.call(this, schema, prev);
      this.item = Schema.makeSchema(schema.items, this);
    }

    ArraySchema.prototype._equal = function(other) {
      return this.item.equal(other.item);
    };

    ArraySchema.prototype.isType = function(v) {
      var item, k, len;
      if (v instanceof Array) {
        for (k = 0, len = v.length; k < len; k++) {
          item = v[k];
          if (!this.item.isa(item)) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };

    ArraySchema.prototype.isOptional = function() {
      var res;
      res = ArraySchema.__super__.isOptional.call(this);
      if (res) {
        return true;
      }
      if (!this.constraint) {
        return true;
      }
      return false;
    };

    ArraySchema.prototype.getDefaultValue = function() {
      if (this.schema.hasOwnProperty('defaultProc') || this.schema.hasOwnProperty('default')) {
        return ArraySchema.__super__.getDefaultValue.call(this);
      } else {
        return [];
      }
    };

    ArraySchema.prototype.valueConvert = function(v, schemaPath) {
      var i, item, k, len, results, values;
      if (typeof v === 'string' && this.schema.hasOwnProperty('delim')) {
        values = v.split(this.schema.delim);
        return this.valueConvert(values, schemaPath);
      } else if (v instanceof Array) {
        results = [];
        for (i = k = 0, len = v.length; k < len; i = ++k) {
          item = v[i];
          results.push(this.item.convert(item, schemaPath.push("$" + i)));
        }
        return results;
      } else {
        return this.invalidType(v, schemaPath);
      }
    };

    ArraySchema.prototype.resolveName = function(name) {
      if (name === '$') {
        return this.item;
      } else {
        return this.unknownProperty(name);
      }
    };

    ArraySchema.prototype.verifyBase = function(baseSchema) {
      return this.finalTypeNonDerivable();
    };

    ArraySchema.prototype._toJSON = function() {
      var res;
      res = {
        items: this.item.toJSON()
      };
      if (this.schema.hasOwnProperty('delim')) {
        res.delim = this.schema.delim;
      }
      return res;
    };

    return ArraySchema;

  })(Schema);

  TupleSchema = (function(superClass) {
    extend(TupleSchema, superClass);

    TupleSchema.prototype.type = 'tuple';

    function TupleSchema(schema, prev) {
      var item;
      this.items = (function() {
        var k, len, ref, results;
        ref = schema.items;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          item = ref[k];
          results.push(Schema.makeSchema(item, this));
        }
        return results;
      }).call(this);
      if (schema.hasOwnProperty('additionalItems')) {
        throw new AppError({
          error: 'unsupportedSchemaProperty',
          property: 'additionalItems',
          schema: schema
        });
      }
      TupleSchema.__super__.constructor.call(this, schema, prev);
    }

    TupleSchema.prototype.equal = function(other) {
      var i, item, k, len, ref;
      if (this.items.length !== other.items.length) {
        return false;
      }
      ref = this.items.length;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        item = ref[i];
        if (!item.equal(other.items[i])) {
          return false;
        }
      }
      return true;
    };

    TupleSchema.prototype.baseLength = function() {
      if (this.hasOwnProperty('$base')) {
        return this.$base.items.length;
      } else {
        return 0;
      }
    };

    TupleSchema.prototype.isType = function(v) {
      var i, item, k, len, ref;
      if (v instanceof Array) {
        if (this.isRightLength(v)) {
          ref = this.items;
          for (i = k = 0, len = ref.length; k < len; i = ++k) {
            item = ref[i];
            if (!item.isa(v[i + this.baseLength()])) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    };

    TupleSchema.prototype.isOptional = function() {
      var item, k, len, ref, res;
      res = TupleSchema.__super__.isOptional.call(this);
      if (res) {
        return true;
      }
      ref = this.items;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (!item.isOptional()) {
          return false;
        }
      }
      return true;
    };

    TupleSchema.prototype.getDefaultValue = function() {
      var item, k, len, ref, results;
      if (this.schema.hasOwnProperty('defaultProc') || this.schema.hasOwnProperty('default')) {
        return TupleSchema.__super__.getDefaultValue.call(this);
      } else {
        ref = this.items;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          item = ref[k];
          results.push(item.getDefaultValue());
        }
        return results;
      }
    };

    TupleSchema.prototype.isRightLength = function(ary) {
      return ary.length >= this.items.length + this.baseLength();
    };

    TupleSchema.prototype.valueConvert = function(v, schemaPath) {
      var i, item, j, k, len, ref, res;
      if (v instanceof Array) {
        this.ensureLength(v, schemaPath);
        res = [];
        ref = this.items;
        for (i = k = 0, len = ref.length; k < len; i = ++k) {
          item = ref[i];
          j = i + this.baseLength();
          res.push(item.convert(v[j], schemaPath.push("${j}")));
        }
        return res;
      } else {
        return this.invalidType(v, schemaPath);
      }
    };

    TupleSchema.prototype.ensureLength = function(ary, schemaPath) {
      var res;
      res = this.isRightLength(ary);
      if (!res) {
        throw new AppError({
          error: 'invalidLength',
          schema: this.schema,
          path: schemaPath,
          length: ary.length
        });
      }
    };

    TupleSchema.prototype._toJSON = function() {
      var item, res;
      res = TupleSchema.__super__._toJSON.call(this);
      res.items = (function() {
        var k, len, ref, results;
        ref = this.items;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          item = ref[k];
          results.push(item.toJSON());
        }
        return results;
      }).call(this);
      return res;
    };

    return TupleSchema;

  })(Schema);

  ObjectSchema = (function(superClass) {
    extend(ObjectSchema, superClass);

    ObjectSchema.prototype.type = 'object';

    function ObjectSchema(schema, prev) {
      var key, val;
      this.properties = (function() {
        var ref, results;
        if (schema.hasOwnProperty('properties')) {
          ref = schema.properties;
          results = [];
          for (key in ref) {
            val = ref[key];
            results.push([key, Schema.makeSchema(val, this)]);
          }
          return results;
        } else {
          return [];
        }
      }).call(this);
      ObjectSchema.__super__.constructor.call(this, schema, prev);
      if (_isFunction(schema.$init)) {
        this.$init = schema.$init;
      }
    }

    ObjectSchema.prototype.equal = function(other) {
      var i, k, key, len, otherKey, otherVal, ref, ref1, ref2, val;
      if (this.properties.length !== other.properties.length) {
        return false;
      }
      ref = this.properties;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        ref1 = ref[i], key = ref1[0], val = ref1[1];
        ref2 = other.properties[i], otherKey = ref2[0], otherVal = ref2[1];
        if (key !== otherKey) {
          return false;
        }
        if (!val.equal(otherVal)) {
          return false;
        }
      }
      return true;
    };

    ObjectSchema.prototype.isType = function(v) {
      var k, key, len, ref, ref1, schema;
      if (this.$init) {
        return v instanceof this.$init;
      }
      if (v instanceof Object) {
        ref = this.properties;
        for (k = 0, len = ref.length; k < len; k++) {
          ref1 = ref[k], key = ref1[0], schema = ref1[1];
          if (!schema.isa(v[key])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };

    ObjectSchema.prototype.isOptional = function() {
      var k, key, len, prop, ref, ref1, res;
      res = ObjectSchema.__super__.isOptional.call(this);
      if (res) {
        true;
      }
      ref = this.properties;
      for (k = 0, len = ref.length; k < len; k++) {
        ref1 = ref[k], key = ref1[0], prop = ref1[1];
        if (!prop.isOptional()) {
          return false;
        }
      }
      return true;
    };

    ObjectSchema.prototype.getDefaultValue = function() {
      var k, key, len, prop, ref, ref1, res;
      if (this.schema.hasOwnProperty('defaultProc') || this.schema.hasOwnProperty('default')) {
        return ObjectSchema.__super__.getDefaultValue.call(this);
      } else {
        res = {};
        ref = this.properties;
        for (k = 0, len = ref.length; k < len; k++) {
          ref1 = ref[k], key = ref1[0], prop = ref1[1];
          res[key] = prop.getDefaultValue();
        }
        return res;
      }
    };

    ObjectSchema.prototype.valueConvert = function(v, schemaPath) {
      var k, key, len, ref, ref1, res, schema;
      if (schemaPath == null) {
        schemaPath = new SchemaPath();
      }
      if (v instanceof Object) {
        res = {};
        ref = this.properties;
        for (k = 0, len = ref.length; k < len; k++) {
          ref1 = ref[k], key = ref1[0], schema = ref1[1];
          res[key] = schema.convert(v[key], schemaPath.push(key));
        }
        return res;
      } else {
        return this.invalidType(v, schemaPath);
      }
    };

    ObjectSchema.prototype.resolveName = function(name) {
      var k, key, len, ref, ref1, val;
      ref = this.properties;
      for (k = 0, len = ref.length; k < len; k++) {
        ref1 = ref[k], key = ref1[0], val = ref1[1];
        if (key === name) {
          return val;
        }
      }
      return this.unknownProperty(name);
    };

    ObjectSchema.prototype._toJSON = function() {
      var item, k, key, len, ref, ref1, res;
      res = ObjectSchema.__super__._toJSON.call(this);
      res.properties = {};
      ref = this.properties;
      for (k = 0, len = ref.length; k < len; k++) {
        ref1 = ref[k], key = ref1[0], item = ref1[1];
        res.properties[key] = item.toJSON();
      }
      return res;
    };

    return ObjectSchema;

  })(Schema);

  MapSchema = (function(superClass) {
    extend(MapSchema, superClass);

    MapSchema.prototype.type = 'map';

    function MapSchema(schema, prev) {
      MapSchema.__super__.constructor.call(this, schema, prev);
      this.property = Schema.makeSchema(schema.additionalProperties, this);
    }

    MapSchema.prototype._equal = function(other) {
      return this.property.equal(other.property);
    };

    MapSchema.prototype.isType = function(v) {
      var key, val;
      for (key in v) {
        val = v[key];
        if (v.hasOwnProperty(key)) {
          if (!this.property.isa(val)) {
            return false;
          }
        }
      }
      return true;
    };

    MapSchema.prototype.isOptional = function() {
      var res;
      res = MapSchema.__super__.isOptional.call(this);
      if (res) {
        return true;
      }
      if (!this.constraint) {
        return true;
      }
      return false;
    };

    MapSchema.prototype.getDefaultValue = function() {
      if (this.schema.hasOwnProperty('defaultProc') || this.schema.hasOwnProperty('default')) {
        return MapSchema.__super__.getDefaultValue.call(this);
      } else {
        return {};
      }
    };

    MapSchema.prototype.valueConvert = function(v, schemaPath) {
      var key, res, val;
      res = {};
      for (key in v) {
        val = v[key];
        if (v.hasOwnProperty(key)) {
          res[key] = this.property.convert(val, schemaPath.push(key));
        }
      }
      return res;
    };

    MapSchema.prototype.resolveName = function(name) {
      return name;
    };

    MapSchema.prototype.verifyBase = function(baseSchema) {
      return this.finalTypeNonDerivable();
    };

    MapSchema.prototype._toJSON = function() {
      var res;
      res = MapSchema.__super__._toJSON.call(this);
      res.additionalProperties = this.property.toJSON();
      return res;
    };

    return MapSchema;

  })(Schema);

  OneOfSchema = (function(superClass) {
    extend(OneOfSchema, superClass);

    OneOfSchema.prototype.type = 'oneOf';

    function OneOfSchema(schema, prev) {
      var type;
      this.items = (function() {
        var k, len, ref, results;
        ref = schema.type;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          type = ref[k];
          results.push(Schema.makeSchema(_extend({}, schema, {
            type: type
          }), this));
        }
        return results;
      }).call(this);
      OneOfSchema.__super__.constructor.call(this, schema, prev);
    }

    OneOfSchema.prototype._equal = function(other) {
      var i, item, k, len, ref;
      if (this.items.length !== other.items.length) {
        return false;
      }
      ref = this.items;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        item = ref[i];
        if (!item.equal(other.items[i])) {
          return false;
        }
      }
      return true;
    };

    OneOfSchema.prototype.isType = function(v) {
      var k, len, ref, schema;
      ref = this.items;
      for (k = 0, len = ref.length; k < len; k++) {
        schema = ref[k];
        if (schema.isa(v)) {
          return true;
        }
      }
      return false;
    };

    OneOfSchema.prototype.isOptional = function() {
      var item, k, len, ref, res;
      res = OneOfSchema.__super__.isOptional.call(this);
      if (res) {
        return true;
      }
      ref = this.items;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (item.isOptional()) {
          return true;
        }
      }
      return false;
    };

    OneOfSchema.prototype.getDefaultValue = function() {
      var e, error, item, k, len, ref;
      if (this.schema.hasOwnProperty('defaultProc') || this.schema.hasOwnProperty('default')) {
        return OneOfSchema.__super__.getDefaultValue.call(this);
      } else {
        ref = this.items;
        for (k = 0, len = ref.length; k < len; k++) {
          item = ref[k];
          try {
            return item.getDefaultValue();
          } catch (error) {
            e = error;
            continue;
          }
        }
      }
    };

    OneOfSchema.prototype.valueConvert = function(v, schemaPath) {
      var e, error, i, k, len, ref, schema;
      ref = this.items;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        schema = ref[i];
        try {
          return schema.convert(v, schemaPath.push("${i}"));
        } catch (error) {
          e = error;
          continue;
        }
      }
      return this.invalidType(v, schemaPath);
    };

    OneOfSchema.prototype.resolveName = function(name) {
      var index, matched;
      matched = name.match(/^\$(\d+)$/);
      if (matched) {
        index = parseInt(matched[1]);
        if (0 <= index && index < this.items.length) {
          return this.items[index];
        } else {
          return this.unknownProperty(name);
        }
      } else {
        return this.unknownProperty(name);
      }
    };

    OneOfSchema.prototype.verifyBase = function(baseSchema) {
      return this.finalTypeNonDerivable();
    };

    OneOfSchema.prototype._toJSON = function() {
      var i, item, json, k, len, ref, result;
      result = {};
      ref = this.items;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        item = ref[i];
        json = item.toJSON();
        if (i > 0) {
          result.type = [json.type];
        } else {
          result.type.push(json.type);
        }
        delete json.type;
        _extend(result, json);
      }
      return result;
    };

    return OneOfSchema;

  })(Schema);

  AllOfSchema = (function(superClass) {
    extend(AllOfSchema, superClass);

    AllOfSchema.prototype.type = 'allOf';

    function AllOfSchema(schema, prev) {
      var item;
      this.items = (function() {
        var k, len, ref, results;
        ref = schema.allOf;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          item = ref[k];
          results.push(Schema.makeSchema(inner, this));
        }
        return results;
      }).call(this);
      AllOfSchema.__super__.constructor.call(this, schema, prev);
    }

    AllOfSchema.prototype._equal = function(other) {
      var i, item, k, len, ref;
      if (this.items.length !== other.items.length) {
        return false;
      }
      ref = this.items;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        item = ref[i];
        if (!item.equal(item.items[i])) {
          return false;
        }
      }
      return true;
    };

    AllOfSchema.prototype.isType = function(v) {
      var k, len, ref, schema;
      ref = this.items;
      for (k = 0, len = ref.length; k < len; k++) {
        schema = ref[k];
        if (!schema.isa(v)) {
          return false;
        }
      }
      return true;
    };

    AllOfSchema.prototype.valueConvert = function(v, schemaPath) {
      var i, k, len, ref, schema, val;
      val = v;
      ref = this.items;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        schema = ref[i];
        val = schema.convert(val, schemaPath.push("${i}"));
      }
      return val;
    };

    AllOfSchema.prototype._toJSON = function() {
      return this.schema;
    };

    return AllOfSchema;

  })(Schema);

  ProcedureSchema = (function(superClass) {
    extend(ProcedureSchema, superClass);

    ProcedureSchema.prototype.type = 'procedure';

    function ProcedureSchema(schema, prev) {
      var item;
      ProcedureSchema.__super__.constructor.call(this, schema, prev);
      this.params = (function() {
        var k, len, ref, results;
        ref = schema.params || [];
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          item = ref[k];
          results.push(Schema.makeSchema(item, this));
        }
        return results;
      }).call(this);
      this.restParams = schema.restParams ? Schema.makeSchema(schema.restParams, this) : null;
      if (this.restParams instanceof ProcedureSchema) {
        throw new AppError({
          error: 'RestParamCannotBeProcedure',
          schema: schema
        });
      }
      this.returns = schema.returns ? Schema.makeSchema(schema.returns, this) : null;
      this.async = schema.async || false;
      this.arity = this.getArity();
    }

    ProcedureSchema.prototype._equal = function(other) {
      var i, k, len, param, ref;
      if (this.params.length !== other.params.length) {
        return false;
      }
      ref = this.params;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        param = ref[i];
        if (!param.equal(other.params[i])) {
          return false;
        }
      }
      if (this.restParams) {
        if (!this.restParams.equal(other.restParams)) {
          return false;
        }
      }
      if (!this.returns.equal(other.returns)) {
        return false;
      }
      if (this.async !== other.async) {
        return false;
      }
      return true;
    };

    ProcedureSchema.prototype.isType = function(v) {
      if (_isFunction(v)) {
        if (v.hasOwnProperty('_schema')) {
          return this.equal(v._schema);
        }
      } else {
        return false;
      }
    };

    ProcedureSchema.prototype.equal = function(schema) {
      if (schema instanceof ProcedureSchema) {

      } else {
        return false;
      }
    };

    ProcedureSchema.prototype.convert = function(v) {
      throw new AppError({
        error: 'notSupported',
        methd: 'ProcedureSchema.convert',
        schema: this.schema,
        value: v
      });
    };

    ProcedureSchema.prototype.getArity = function() {
      var k, len, max, min, param, ref;
      min = 0;
      ref = this.params;
      for (k = 0, len = ref.length; k < len; k++) {
        param = ref[k];
        if (param.isRequired()) {
          min++;
        }
      }
      max = this.params.length;
      if (this.restParams) {
        max = 32767 - 1;
      }
      return {
        min: min,
        max: max
      };
    };

    ProcedureSchema.prototype.extractCallback = function(args) {
      var cb;
      if (this.arity.min === this.arity.max) {
        if (args.length === this.arity.min) {
          return [args, void 0];
        } else if (args.length > this.arity.min && _isFunction(args[args.length - 1])) {
          cb = args[args.length - 1];
          return [args.slice(0, args.length - 1), cb];
        } else {
          return [args, void 0];
        }
      } else if (args.length <= this.arity.min) {
        return [args, void 0];
      } else if (!_isFunction(args[args.length - 1])) {
        return [args, void 0];
      } else {
        cb = args[args.length - 1];
        return [args.slice(0, args.length - 1), cb];
      }
    };

    ProcedureSchema.prototype.validateArity = function(args) {
      if (args.length < this.arity.min) {
        throw new AppError({
          error: 'arityErrorLessThanMin',
          arity: this.arity,
          args: args,
          schema: this.schema
        });
      }
      if (args.length > this.arity.max) {
        throw new AppError({
          error: 'arityErrorGreaterThanMax',
          arity: this.arity,
          args: args,
          schema: this.schema
        });
      }
    };

    ProcedureSchema.prototype.fillHoles = function(args) {
      var counter, i, j, k, l, len, normalized, param, ref, ref1, ref2, remainOptional, remainRequired;
      if (this.arity.min === this.arity.max) {
        return args;
      }
      remainRequired = this.arity.min;
      remainOptional = args.length - remainRequired;
      counter = 0;
      normalized = [];
      ref = this.params;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        param = ref[i];
        if (param.isRequired()) {
          if (remainRequired === 0) {
            throw new AppError({
              error: 'requiredParamUnderflow',
              param: param,
              args: args,
              schema: this.schema
            });
          }
          remainRequired--;
          normalized.push(args[counter++]);
        } else if (remainOptional > 0) {
          normalized.push(args[counter++]);
          remainOptional--;
        } else {
          normalized.push(void 0);
        }
      }
      if (counter < args.length - 1) {
        if (!this.restParams) {
          throw new AppError({
            error: 'ParameterOverflow',
            arity: arity,
            args: args,
            schema: this.schema
          });
        }
        for (j = l = ref1 = counter, ref2 = args.length; ref1 <= ref2 ? l < ref2 : l > ref2; j = ref1 <= ref2 ? ++l : --l) {
          normalized.push(args[j]);
        }
      }
      return normalized;
    };

    ProcedureSchema.prototype.validateArguments = function(args) {
      var arg, i, normalized, normed, param, path;
      this.validateArity(args);
      args = this.fillHoles(args);
      path = new SchemaPath();
      normalized = (function() {
        var k, len, results;
        results = [];
        for (i = k = 0, len = args.length; k < len; i = ++k) {
          arg = args[i];
          param = this.params[i];
          if (i < this.params.length) {
            normed = !param.isRequired() && arg === void 0 ? param.getDefaultValue() : arg;
            results.push(param.validate(normed, path.push(i)));
          } else if (this.restParams) {
            results.push(this.restParams.validate(arg, path.push(i)));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }).call(this);
      return normalized;
    };

    ProcedureSchema.prototype.makeFunction = function(proc) {
      var Func, schemaObj;
      schemaObj = this;
      if (schemaObj.async === 'promise') {
        Func = function() {
          var _callback, args, e, error, extracted, normalized, ref, self;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          ref = schemaObj.extractCallback(args), extracted = ref[0], _callback = ref[1];
          self = this;
          if (_isFunction(_callback)) {
            try {
              normalized = schemaObj.validateArguments(extracted);
              return proc.apply(self, normalized).then(function(res) {
                if (schemaObj.returns) {
                  schemaObj.returns.validate(res);
                }
                return res;
              }).then(function(res) {
                return _callback(null, res);
              })["catch"](function(e) {
                return _callback(e);
              });
            } catch (error) {
              e = error;
              return _callback(e);
            }
          } else {
            return Promise["try"](function() {
              return schemaObj.validateArguments(extracted);
            }).then(function(normalized) {
              return proc.apply(self, normalized);
            }).then(function(res) {
              if (schemaObj.returns) {
                schemaObj.returns.validate(res);
              }
              return res;
            });
          }
        };
      } else if (schemaObj.async) {
        Func = function() {
          var _callback, args, e, error, extracted, normalized, ref, self;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          ref = schemaObj.extractCallback(args), extracted = ref[0], _callback = ref[1];
          self = this;
          if (_isFunction(_callback)) {
            try {
              normalized = schemaObj.validateArguments(extracted);
              return proc.call.apply(proc, [self].concat(slice.call(normalized), [function(err, res) {
                var e, error;
                if (err) {
                  return _callback(err);
                } else {
                  try {
                    if (schemaObj.returns) {
                      schemaObj.returns.validate(res);
                    }
                    return _callback(null, res);
                  } catch (error) {
                    e = error;
                    return _callback(e);
                  }
                }
              }]));
            } catch (error) {
              e = error;
              return _callback(e);
            }
          } else {
            return Promise["try"](function() {
              return schemaObj.validateArguments(extracted);
            }).then(function(normalized) {
              return new Promise(function(resolve, reject) {
                return proc.call.apply(proc, [self].concat(slice.call(normalized), [function(err, res) {
                  var error1;
                  if (err) {
                    return reject(err);
                  } else {
                    try {
                      if (schemaObj.returns) {
                        schemaObj.returns.validate(res);
                      }
                      return resolve(res);
                    } catch (error1) {
                      e = error1;
                      return reject(e);
                    }
                  }
                }]));
              });
            });
          }
        };
      } else {
        Func = function() {
          var args, normalized, res;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          normalized = schemaObj.validateArguments(args);
          res = proc.apply(this, normalized);
          if (schemaObj.returns) {
            schemaObj.returns.validate(res);
          }
          return res;
        };
      }
      Func._schema = schemaObj;
      return Func;
    };

    return ProcedureSchema;

  })(Schema);

  InterfaceSchema = (function(superClass) {
    extend(InterfaceSchema, superClass);

    InterfaceSchema.prototype.type = 'interface';

    function InterfaceSchema(schema, prev) {
      var key, val;
      InterfaceSchema.__super__.constructor.call(this, schema, prev);
      if (!schema.hasOwnProperty('$init')) {
        throw new AppError({
          error: 'RequiredParameter',
          name: '$init',
          method: 'InterfaceSchema.ctor'
        });
      }
      this.$init = Schema.makeSchema(schema.$init, this);
      if (!schema.hasOwnProperty('$init')) {
        throw new AppError({
          error: 'RequiredParameter',
          name: '$prototype',
          method: 'InterfaceSchema.ctor'
        });
      }
      this.$prototype = (function() {
        var ref, results;
        ref = schema.$prototype || {};
        results = [];
        for (key in ref) {
          val = ref[key];
          results.push([key, Schema.makeSchema(val, this)]);
        }
        return results;
      }).call(this);
    }

    InterfaceSchema.prototype.implement = function(obj) {
      if (!obj.hasOwnProperty('$init')) {
        throw new AppError({
          error: 'RequiredParameter',
          name: '$prototype',
          method: 'InterfaceSchema.implement'
        });
      }
    };

    return InterfaceSchema;

  })(ObjectSchema);

  module.exports = Schema;

}).call(this);
